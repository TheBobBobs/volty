use indexmap::{IndexMap, IndexSet};
use iso8601_timestamp::Timestamp;
use optional_struct::OptionalStruct;
use serde::{Deserialize, Serialize};
use validator::Validate;

use crate::{
    media::attachment::File,
    servers::server_member::Member,
    types::january::Embed,
    users::user::User,
    util::{
        misc::{if_false, if_option_false, if_zero_u32},
        regex::RE_COLOUR,
    },
};

/// Representation of a message reply before it is sent.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Reply {
    /// Message Id
    pub id: String,
    /// Whether this reply should mention the message's author
    pub mention: bool,
    /// Whether to error if the referenced message doesn't exist.
    /// Otherwise, send a message without this reply.
    /// Default is true.
    pub fail_if_not_exists: Option<bool>,
}

impl From<String> for Reply {
    fn from(value: String) -> Self {
        Self {
            id: value,
            mention: false,
            fail_if_not_exists: None,
        }
    }
}

impl From<&str> for Reply {
    fn from(value: &str) -> Self {
        Self {
            id: value.to_string(),
            mention: false,
            fail_if_not_exists: None,
        }
    }
}

// Representation of a system event message
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum SystemMessage {
    Text {
        content: String,
    },
    UserAdded {
        id: String,
        by: String,
    },
    UserRemove {
        id: String,
        by: String,
    },
    UserJoined {
        id: String,
    },
    UserLeft {
        id: String,
    },
    UserKicked {
        id: String,
    },
    UserBanned {
        id: String,
    },
    ChannelRenamed {
        name: String,
        by: String,
    },
    ChannelDescriptionChanged {
        by: String,
    },
    ChannelIconChanged {
        by: String,
    },
    ChannelOwnershipChanged {
        from: String,
        to: String,
    },
    MessagePinned {
        id: String,
        by: String,
    },
    MessageUnpinned {
        id: String,
        by: String,
    },
    CallStarted {
        by: String,
        finished_at: Option<Timestamp>,
    },
}

/// Name and / or avatar override information
#[derive(Clone, Debug, Default, Deserialize, Serialize, Validate)]
pub struct Masquerade {
    /// Replace the display name shown on this message
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(length(min = 1, max = 32))]
    pub name: Option<String>,
    /// Replace the avatar shown on this message (URL to image file)
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(length(min = 1, max = 128))]
    pub avatar: Option<String>,
    /// Replace the display role colour shown on this message
    ///
    /// Must have `ManageRole` permission to use
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(length(min = 1, max = 128), regex(path = *RE_COLOUR))]
    pub colour: Option<String>,
}

// Information to guide interactions on this message
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Interactions {
    /// Reactions which should always appear and be distinct
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub reactions: Option<IndexSet<String>>,
    /// Whether reactions should be restricted to the given list
    #[serde(skip_serializing_if = "if_false", default)]
    pub restrict_reactions: bool,
}

impl Interactions {
    pub fn new<S: Into<String>>(reactions: impl IntoIterator<Item = S>) -> Self {
        let reactions = reactions.into_iter().map(|s| s.into()).collect();
        Self {
            reactions: Some(reactions),
            restrict_reactions: false,
        }
    }

    pub fn restrict(mut self) -> Self {
        self.restrict_reactions = true;
        self
    }

    pub fn is_default(&self) -> bool {
        !self.restrict_reactions && self.reactions.is_none()
    }
}

#[derive(Clone, Debug, Default, Deserialize, Serialize, OptionalStruct)]
#[optional_derive(Clone, Debug, Default, Deserialize, Serialize)]
#[optional_name = "PartialMessage"]
#[opt_skip_serializing_none]
#[opt_some_priority]
pub struct Message {
    /// Unique Id
    #[serde(rename = "_id")]
    pub id: String,
    /// Unique value generated by client sending this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// Id of the channel this message was sent in
    #[serde(rename = "channel")]
    pub channel_id: String,
    /// Id of the user that sent this message
    #[serde(rename = "author")]
    pub author_id: String,
    #[serde(rename = "user")]
    pub author: Option<User>,
    pub member: Option<Member>,

    /// Message content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    /// System message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system: Option<SystemMessage>,
    /// Array of attachments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Vec<File>>,
    /// Time at which this message was last edited
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edited: Option<Timestamp>,
    /// Attached embeds to this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embeds: Option<Vec<Embed>>,
    /// Array of user ids mentioned in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<String>>,
    /// Array of message ids this message is replying to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replies: Option<Vec<String>>,
    /// Hashmap of emoji IDs to array of user IDs
    #[serde(skip_serializing_if = "IndexMap::is_empty", default)]
    pub reactions: IndexMap<String, IndexSet<String>>,
    /// Information about how this message should be interacted with
    pub interactions: Option<Interactions>,
    /// Name and / or avatar overrides for this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub masquerade: Option<Masquerade>,
    /// Whether or not the message in pinned
    #[serde(skip_serializing_if = "if_option_false")]
    pub pinned: Option<bool>,

    /// Bitfield of message flags
    ///
    /// https://docs.rs/revolt-models/latest/revolt_models/v0/enum.MessageFlags.html
    #[serde(skip_serializing_if = "if_zero_u32", default)]
    pub flags: u32,
}

/// Sort used for retrieving messages
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub enum MessageSort {
    /// Sort by the most relevant messages
    #[default]
    Relevance,
    /// Sort by the newest messages first
    Latest,
    /// Sort by the oldest messages first
    Oldest,
}

/// Response used when multiple messages are fetched
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BulkMessageResponse {
    JustMessages(
        /// List of messages
        Vec<Message>,
    ),
    MessagesAndUsers {
        /// List of messages
        messages: Vec<Message>,
        /// List of users
        users: Vec<User>,
        /// List of members
        #[serde(skip_serializing_if = "Option::is_none")]
        members: Option<Vec<Member>>,
    },
}

/// # Appended Information
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AppendMessage {
    /// Additional embeds to include in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embeds: Option<Vec<Embed>>,
}

#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
#[repr(u32)]
pub enum MessageFlags {
    /// Message will not send push / desktop notifications
    SuppressNotifications = 1,
    /// Message will mention all users who can see the channel
    MentionsEveryone = 2,
    /// Message will mention all users who are online and can see the channel.
    /// This cannot be true if MentionsEveryone is true
    MentionsOnline = 3,
}

#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum FieldsMessage {
    Pinned,
}
